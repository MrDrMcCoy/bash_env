#!/usr/bin/env bash

promptline () {
  local lastexit=$?
  local good='\e[1;32m✔\e[0m'
  local bad='\e[31m✘\e[0m'
  local cwd="$(basename "${PWD}")"
  # show last exit code
  if [ ${lastexit} = 0 ] ; then
    echo -en "\e[32m${lastexit}\e[0m "
  else
    echo -en "\e[1;31m${lastexit}\e[0m "
  fi
  # show timestamp
  echo -en "\e[1;37m$(date +%H:%M:%S)\e[0m "
  # show current directory
  if [ "${PWD}" = "${HOME}" ]; then
    echo -en "\e[1;33m~\e[0m "
  else
    echo -en "\e[1;33m${cwd}\e[0m "
  fi
  # show git branch
  local gs="$(git status --porcelain=v2 --ignore-submodules=all -bsu 2>/dev/null)"
  if [ -n "${gs}" ] ; then
    local reponame="$(basename "$(git rev-parse --show-toplevel)")"
    local branch="$(awk -F '[ .]' '/##/{print $2}' <<< "${gs}")"
    local ahead="$(grep -o '(?<=ahead )\d+' /dev/stdin <<< "${gs}")"
    local behind="$(grep -o '(?<=behind )\d+' /dev/stdin <<< "${gs}")"
    local modified="$(grep -ic '^( |d|a|m|r)+' /dev/stdin <<< "${gs}")"
    local untracked="$(grep -c '^( |\?)+' /dev/stdin <<< "${gs}")"
    echo -en "["
    [ "${cwd}" != "${reponame}" ] && echo -en "\e[1;36m${reponame}\e[0m "
    echo -en "${branch:+\\e[1;35m}${branch}${branch:+\\e[0m}"
    [ "${ahead}" = 0 ] || echo -en "${ahead:+ A}${ahead}"
    [ "${behind}" = 0 ] || echo -en "${behind:+ B}${behind}"
    [ "${deleted}" = 0 ] || echo -en "${deleted:+ D}${deleted}"
    [ "${modified}" = 0 ] || echo -en "${modified:+ M}${modified}"
    [ "${untracked}" = 0 ] || echo -en "${untracked:+ U}${untracked}"
    echo -en "] "
  fi
  # show shell line
  if [ ${EUID} = 0 ] ; then
    echo -n "\e[1;33m# \e[0m"
  else
    echo -n "\e[1;32m$ \e[0m"
  fi
  echo
  return ${lastexit}
}

# This allows the function to be run as a script if this file is executed directly
[[ $- == *i* ]] || promptline "$@"
