#!/usr/bin/env bash

pm() {
  local task="${1}"
  shift
  if command -v yay ; then
    local cmd="yay"
    local cleanup="yay -Ycc ; yay --noconfirm -Scc"
    local checkflags=(-Sy)
    local rmflags=(-Rsu)
    local upflags=(-u --combinedupgrade)
    local searchflags=(-Ss)
    local inflags=(-S
      --batchinstall
      --needed
      --nocleanmenu
      --nodiffmenu
      --noeditmenu
      --norebuild
      --noredownload
      --noremovemake
    )
    local panicflags=(
      --batchinstall
      --nocleanmenu
      --nodiffmenu
      --noeditmenu
      --rebuildall
      --redownloadall
      --removemake
    )
  else
    echo "ERROR: no supported package managers found."
    return
  fi
  case "${task}" in
    c*)
      ${cmd} ${checkflags[@]} "$@" || return
      ;;
    i*)
      ${cmd} ${inflags[@]} "$@" || return
      eval ${cleanup}
      ;;
    u*)
      ${cmd} ${inflags[@]} ${upflags[@]} "$@" || return
      eval ${cleanup}
      ;;
    r*)
      ${cmd} ${rmflags[@]} "$@" || return
      eval ${cleanup}
      ;;
    p*)
      yay -Qq | yay -S ${panicflags[@]} - || return
      eval ${cleanup}
      ;;
    s*)
      ${cmd} ${searchflags[@]} "$@"
      ;;
    h*) fold -sw "${COLUMNS:-80}" <<EOF
pm: a package manager wrapper

Usage: pm [task] [argument]... [package]...

Tasks:
    check: check for new packages
    install: install packages
    upgrade: upgrade packages
    panic: reinstall all packages
    remove: remove packages
    search: searches packages
    help: print this text

Arguments: anything you would normally pass to your system package manager.

pm will set the preferred defaults of the author for each operation, then run a cleanup task at the end of a successful run. Don't like it, don't use it.

Supported package managers:
  - yay

More features will come eventually.
EOF
    ;;
    *) echo "ERROR: '${task}' is not implemented. Try 'pm help'" ;;
  esac
}

# This allows the function to be run as a script if this file is executed directly
[[ $- == *i* ]] || pm "$@"
